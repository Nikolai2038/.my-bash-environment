#!/bin/bash

# (REUSE)
# Code that must be included in every script to make it fully independent and compatible with refactoring in IDEs.
# Advices for code writing:
# - It is recommended to use lower case variables' names, cause some IDE ignore "not found variables" errors if they are upper cased.
{
  # Fail command if any of pipeline blocks fail
  set -o pipefail

  # Special function to get current script file hash
  function get_text_hash() {
    echo "${*}" | sha256sum | cut -d ' ' -f 1 || return "$?"
    return 0
  }

  # Source this file only if wasn't sourced already
  {
    current_file_path="$(realpath "${BASH_SOURCE[0]}")" || exit "$?"
    current_file_hash="$(echo "${current_file_path}" | sha256sum | cut -d ' ' -f 1)" || exit "$?"
    current_file_is_sourced_variable_name="FILE_IS_SOURCED_${current_file_hash^^}"
    current_file_is_sourced="$(eval "echo \"\${${current_file_is_sourced_variable_name}}\"")" || exit "$?"
    if [ -n "${current_file_is_sourced}" ]; then
      return
    fi
    eval "export ${current_file_is_sourced_variable_name}=1" || exit "$?"
    if ((IS_DEBUG_BASH)); then
      if [ "${0}" == "${BASH_SOURCE[0]}" ]; then
        echo "Executing \"${current_file_path}\"..." >&2
      else
        echo "Sourcing \"${current_file_path}\"..." >&2
      fi
    fi
    # Unset script-scope variables, to skip references on them between files
    unset current_file_path current_file_hash current_file_is_sourced_variable_name current_file_is_sourced
  }

  # Prepare before imports
  {
    # Because variables is the same when sourcing, we depend on file hash.
    # Also, we don't use variable for variable name here, because it will fall in the same problem.
    # We must pass "${BASH_SOURCE[*]}" as a variable and not define it in the function itself, because Bash will replace it there.
    eval "source_previous_directory_$(get_text_hash "${BASH_SOURCE[*]}")=\"${PWD}\"" || exit "$?"

    # We use "cd" instead of specifying file paths directly in the "source" comment, because these comments do not change when files are renamed or moved.
    # Moreover, we need to specify exact paths in "source" to use links to function and variables between files (language server).
    cd "$(dirname "$(realpath "${BASH_SOURCE[0]}")")" || exit "$?"

    # We don't use "set -e" for all scripts, but it is useful to simplify testing imports, so we enable it here and disable below.
    # Why it is bad see:
    # - https://unix.stackexchange.com/questions/405382/set-e-inside-a-bash-function
    # - http://mywiki.wooledge.org/BashFAQ/105/Answers
    set -e
  }
}

# Imports
source "./_n2038_error_if_snapper_is_not_installed"
source "./n2038_snapper_list_configs"
source "../sudo/_constants"
source "../sudo/_n2038_update_sudo_rights"
source "./_constants"
source "./_n2038_snapper_echo_snapshot_id"
source "./_n2038_snapper_echo_snapshot_description"

# (REUSE) Prepare after imports
{
  # Disable "set -e" because it's behaviour is less understandable
  set +e

  eval "cd \"\${source_previous_directory_$(get_text_hash "${BASH_SOURCE[*]}")}\"" || exit "$?"

  # Unset script-scope variables, to skip references on them between files
  unset "source_previous_directory_$(get_text_hash "${BASH_SOURCE[*]}")" || exit "$?"
}

# Rollback specified config to specified snapshot n2038_number
function n2038_snapper_goto_custom() {
  _n2038_error_if_snapper_is_not_installed || return "$?"
  _n2038_update_sudo_rights || return "$?"

  local config="${1}" && shift
  if [ -z "${config}" ]; then
    echo "Usage: ${FUNCNAME[0]} <config name> <n2038_number>" >&2
    local list_of_available_configs
    list_of_available_configs="$(n2038_snapper_list_configs | tr '\n' ' ')" || return "$?"
    echo "Available configs: ${list_of_available_configs}" >&2
    return 1
  fi

  local n2038_number="${1}" && shift
  if [ -z "${n2038_number}" ]; then
    echo "Usage: ${FUNCNAME[0]} <config name> <n2038_number>" >&2
    return 1
  fi

  local subvolume_path
  subvolume_path="$(sudo sed -En 's/^SUBVOLUME="(.+?)"$/\1/p' "/etc/snapper/configs/${config}")" || return "$?"
  echo "Subvolume path: \"${subvolume_path}\"." >&2

  local subvolume_name
  subvolume_name="$(sed -En "s#^UUID=([^[:blank:]]+).+?[[:blank:]]+${subvolume_path}[[:blank:]]+btrfs[[:blank:]]+.+?subvol=([^[:blank:]]+).*\$#\\2#p" /etc/fstab)" || return "$?"
  echo "Subvolume name: \"${subvolume_name}\"." >&2

  local subvolume_uuid
  subvolume_uuid="$(sed -En "s#^UUID=([^[:blank:]]+).+?[[:blank:]]+${subvolume_path}[[:blank:]]+btrfs[[:blank:]]+.+?subvol=([^[:blank:]]+).*\$#\\1#p" /etc/fstab)" || return "$?"
  echo "Subvolume UUID: \"${subvolume_uuid}\"." >&2

  local subvolume_raw_path_prefix
  subvolume_raw_path_prefix="$(grep -v 'subvol=' /etc/fstab | sed -En "s#^UUID=${subvolume_uuid}.+?[[:blank:]]+([^[:blank:]]+)[[:blank:]]+btrfs[[:blank:]]+.+?\$#\\1#p")" || return "$?"
  local subvolume_raw_path="${subvolume_raw_path_prefix}/${subvolume_name}" || return "$?"
  echo "Subvolume raw path: \"${subvolume_raw_path}\"." >&2
  if [ ! -e "${subvolume_raw_path}" ]; then
    echo "Subvolume raw path \"${subvolume_raw_path}\" does not exist!" >&2
    return 1
  fi

  local subvolume_snapshots_raw_path="${subvolume_raw_path_prefix}/${subvolume_name}-snapshots" || return "$?"
  echo "Subvolume snapshots raw path: \"${subvolume_snapshots_raw_path}\"." >&2
  if [ ! -e "${subvolume_snapshots_raw_path}" ]; then
    echo "Subvolume snapshots raw path \"${subvolume_snapshots_raw_path}\" does not exist!" >&2
    return 1
  fi

  local snapshot_id
  snapshot_id="$(_n2038_snapper_echo_snapshot_id "${config}" "${n2038_number}")" || return "$?"
  echo "Snapshot ID: \"${snapshot_id}\"." >&2

  local snapshot_description
  snapshot_description="$(_n2038_snapper_echo_snapshot_description "${config}" "${n2038_number}")" || return "$?"
  echo "Snapshot description: \"${snapshot_description}\"." >&2

  # TODO: Create auto-backup snapshot
  # # We pass empty string for second argument to not add prefix
  # n2038_snapper_create_with_description "Auto-backup before restoring to #${n2038_number} \"${snapshot_description//"${BY_HAND_PREFIX}"/}\"" "" || return "$?"
  # # Because we created snapshots right now, we must increase n2038_number by 1
  # ((n2038_number++))

  # rootfs
  if [ "${subvolume_path}" = "/" ]; then
    # shellcheck disable=SC2086
    echo CONFIRM | ${n2038_sudo_prefix}snapper-rollback "${snapshot_id}" || return "$?"
  # others
  else
    # Create backup
    # shellcheck disable=SC2086
    ${n2038_sudo_prefix}mv --no-target-directory "${subvolume_raw_path}" "${subvolume_raw_path}_old" || return "$?"

    # shellcheck disable=SC2086
    ${n2038_sudo_prefix}btrfs subvolume snapshot "${subvolume_snapshots_raw_path}/${snapshot_id}/snapshot" "${subvolume_raw_path}" || {
      # Discard changes if something went wrong
      ${n2038_sudo_prefix}mv --no-target-directory "${subvolume_raw_path}_old" "${subvolume_raw_path}" || return "$?"

      echo "Something went wrong! Changes were discarded." >&2
      return 1
    }
  fi

  echo "Success! Now you have to reboot to apply changes!" >&2

  return 0
}

# Add the ability to execute this script by itself (for debugging)
{
  if [ "${0}" == "${BASH_SOURCE[0]}" ]; then
    n2038_snapper_goto_custom "${@}"
  fi
}
